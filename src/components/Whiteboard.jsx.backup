import React, { useRef, useEffect, useState, useCallback } from 'react';
import { useWhiteboard } from '../context/WhiteboardContext';
import { snapToRulerEdge, pointInRect, lineIntersectsRect } from '../utils/geometry';
import SelectionActionMenu from './SelectionActionMenu';

const Whiteboard = () => {
    const canvasRef = useRef(null);
    const [isDrawing, setIsDrawing] = useState(false);
    const [currentPath, setCurrentPath] = useState([]);
    const [draggedElement, setDraggedElement] = useState(null);
    const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
    const [selectionBox, setSelectionBox] = useState(null);
    const [selectedElements, setSelectedElements] = useState([]);
    const [isErasing, setIsErasing] = useState(false);

    const {
        activeTool,
        toolProperties,
        elements,
        addElement,
        updateElement,
        deleteElement,
        ruler,
        setRuler,
        protractor,
        setProtractor,
        selectedElement,
        setSelectedElement
    } = useWhiteboard();

    // Initialize canvas
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const handleResize = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            redrawCanvas();
        };

        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, []);

    // Redraw canvas whenever elements change
    useEffect(() => {
        redrawCanvas();
    }, [elements, ruler, protractor, selectedElement]);

    const redrawCanvas = useCallback(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw all elements
        elements.forEach(element => {
            if (element.type === 'stroke') {
                drawStroke(ctx, element);
            } else if (element.type === 'text') {
                drawText(ctx, element);
            } else if (element.type === 'equation') {
                drawEquation(ctx, element);
            }
        });

        // Draw ruler if active
        if (ruler) {
            drawRuler(ctx, ruler);
        }

        // Draw protractor if active
        if (protractor) {
            drawProtractor(ctx, protractor);
        }

        // Draw selection box
        if (selectedElement) {
            drawSelectionBox(ctx, selectedElement);
        }

        // Draw multiple selections
        if (selectedElements.length > 0) {
            selectedElements.forEach(el => drawSelectionBox(ctx, el));
        }

        // Draw selection rectangle (drag box)
        if (selectionBox) {
            ctx.strokeStyle = '#007AFF';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.fillStyle = 'rgba(0, 122, 255, 0.1)';
            ctx.fillRect(selectionBox.x, selectionBox.y, selectionBox.width, selectionBox.height);
            ctx.strokeRect(selectionBox.x, selectionBox.y, selectionBox.width, selectionBox.height);
            ctx.setLineDash([]);
        }
    }, [elements, ruler, protractor, selectedElement, selectedElements, selectionBox]);

    const drawStroke = (ctx, element) => {
        if (!element.points || element.points.length === 0) return;

        ctx.beginPath();
        ctx.strokeStyle = element.color;
        ctx.lineWidth = element.thickness;
        ctx.globalAlpha = element.opacity;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        ctx.moveTo(element.points[0].x, element.points[0].y);
        for (let i = 1; i < element.points.length; i++) {
            ctx.lineTo(element.points[i].x, element.points[i].y);
        }
        ctx.stroke();
        ctx.globalAlpha = 1;
    };

    const drawText = (ctx, element) => {
        ctx.font = `${element.fontSize}px ${element.fontFamily}`;
        ctx.fillStyle = element.color;
        ctx.globalAlpha = element.opacity || 1;
        ctx.fillText(element.text, element.x, element.y);
        ctx.globalAlpha = 1;
    };

    const drawEquation = (ctx, element) => {
        if (element.html) {
            // Create temporary div to render the HTML
            const tempDiv = document.createElement('div');
            tempDiv.style.position = 'absolute';
            tempDiv.style.left = '-9999px';
            tempDiv.style.fontSize = `${element.fontSize}px`;
            tempDiv.style.color = element.color;
            tempDiv.innerHTML = element.html;
            document.body.appendChild(tempDiv);

            // Use foreignObject SVG to draw on canvas
            const bbox = tempDiv.getBoundingClientRect();
            const svg = `
                <svg xmlns="http://www.w3.org/2000/svg" width="${element.width}" height="${element.height}">
                    <foreignObject width="100%" height="100%">
                        <div xmlns="http://www.w3.org/1999/xhtml" style="font-size: ${element.fontSize}px; color: ${element.color}; padding: 10px;">
                            ${element.html}
                        </div>
                    </foreignObject>
                </svg>
            `;

            const img = new Image();
            const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);

            img.onload = () => {
                ctx.globalAlpha = element.opacity || 1;
                ctx.drawImage(img, element.x, element.y, element.width, element.height);
                ctx.globalAlpha = 1;
                URL.revokeObjectURL(url);
                document.body.removeChild(tempDiv);
            };

            img.src = url;
        }
    };

    const drawRuler = (ctx, ruler) => {
        ctx.save();

        // Draw ruler body with glass effect
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 2;

        ctx.fillRect(ruler.x, ruler.y, ruler.width, ruler.height);
        ctx.strokeRect(ruler.x, ruler.y, ruler.width, ruler.height);

        // Draw measurement marks
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.lineWidth = 1;
        const markCount = 20;
        for (let i = 0; i <= markCount; i++) {
            const x = ruler.x + (ruler.width / markCount) * i;
            const markHeight = i % 5 === 0 ? 15 : 8;
            ctx.beginPath();
            ctx.moveTo(x, ruler.y);
            ctx.lineTo(x, ruler.y + markHeight);
            ctx.stroke();

            // Draw numbers for major marks
            if (i % 5 === 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '10px Inter';
                ctx.fillText(i.toString(), x - 5, ruler.y + 25);
            }
        }

        ctx.restore();
    };

    const drawProtractor = (ctx, protractor) => {
        ctx.save();

        // Draw semi-circle with glass effect
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.arc(protractor.x, protractor.y, protractor.radius, 0, Math.PI);
        ctx.fill();
        ctx.stroke();

        // Draw angle markers
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.lineWidth = 1;
        ctx.font = '10px Inter';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';

        for (let angle = 0; angle <= 180; angle += 10) {
            const rad = (angle * Math.PI) / 180;
            const x1 = protractor.x + Math.cos(rad) * protractor.radius;
            const y1 = protractor.y + Math.sin(rad) * protractor.radius;
            const markLength = angle % 30 === 0 ? 15 : 8;
            const x2 = protractor.x + Math.cos(rad) * (protractor.radius - markLength);
            const y2 = protractor.y + Math.sin(rad) * (protractor.radius - markLength);

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            if (angle % 30 === 0) {
                const textX = protractor.x + Math.cos(rad) * (protractor.radius - 25);
                const textY = protractor.y + Math.sin(rad) * (protractor.radius - 25);
                ctx.fillText(angle.toString(), textX - 10, textY + 5);
            }
        }

        ctx.restore();
    };

    const drawSelectionBox = (ctx, element) => {
        let bounds;
        if (element.type === 'stroke') {
            bounds = getStrokeBounds(element);
        } else if (element.type === 'text') {
            ctx.font = `${element.fontSize}px ${element.fontFamily}`;
            const metrics = ctx.measureText(element.text);
            bounds = {
                x: element.x,
                y: element.y - element.fontSize,
                width: metrics.width,
                height: element.fontSize
            };
        } else if (element.type === 'equation') {
            bounds = {
                x: element.x,
                y: element.y,
                width: element.width,
                height: element.height
            };
        }

        if (bounds) {
            ctx.strokeStyle = '#007AFF';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(bounds.x - 5, bounds.y - 5, bounds.width + 10, bounds.height + 10);
            ctx.setLineDash([]);
        }
    };

    const getStrokeBounds = (element) => {
        if (!element.points || element.points.length === 0) return null;

        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        element.points.forEach(p => {
            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x);
            maxY = Math.max(maxY, p.y);
        });

        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    };

    const getMousePos = (e) => {
        const canvas = canvasRef.current;
        const rect = canvas.getBoundingClientRect();
        return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
    };

    const isPointNearElement = (pos, element) => {
        if (element.type === 'stroke') {
            return element.points.some(p =>
                Math.hypot(p.x - pos.x, p.y - pos.y) < toolProperties.thickness + 10
            );
        } else if (element.type === 'text') {
            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            ctx.font = `${element.fontSize}px ${element.fontFamily}`;
            const metrics = ctx.measureText(element.text);
            return pointInRect(pos.x, pos.y, {
                x: element.x,
                y: element.y - element.fontSize,
                width: metrics.width,
                height: element.fontSize
            });
        } else if (element.type === 'equation') {
            return pointInRect(pos.x, pos.y, {
                x: element.x,
                y: element.y,
                width: element.width,
                height: element.height
            });
        }
        return false;
    };

    const handleMouseDown = (e) => {
        const pos = getMousePos(e);

        if (activeTool === 'pen') {
            setIsDrawing(true);
            setCurrentPath([pos]);
        } else if (activeTool === 'eraser') {
            setIsErasing(true);
            // Find and delete element at position
            const elementToDelete = elements.find(el => isPointNearElement(pos, el));
            if (elementToDelete) {
                deleteElement(elementToDelete.id);
            }
        } else if (activeTool === 'select') {
            // Check if clicking on existing element
            const clickedElement = elements.find(el => isPointNearElement(pos, el));

            if (clickedElement) {
                // If shift key, add to selection
                if (e.shiftKey) {
                    setSelectedElements(prev =>
                        prev.includes(clickedElement)
                            ? prev.filter(el => el.id !== clickedElement.id)
                            : [...prev, clickedElement]
                setSelectedElement(null);
                    setSelectedElements([]);
                }
            } else if (activeTool === 'ruler') {
                // Place ruler at mouse position
                setRuler({
                    x: pos.x - 150,
                    y: pos.y - 20,
                    width: 300,
                    height: 40
                });
            } else if (activeTool === 'protractor') {
                // Place protractor at mouse position
                setProtractor({
                    x: pos.x,
                    y: pos.y,
                    radius: 100,
                    startAngle: 0,
                    endAngle: Math.PI
                });
            }
        };

        const handleMouseMove = (e) => {
            const pos = getMousePos(e);

            if (isErasing && activeTool === 'eraser') {
                // Continue erasing while dragging - use a ref to track last deleted to avoid re-deletion
                const elementsToCheck = [...elements]; // Create a copy to iterate
                for (const el of elementsToCheck) {
                    if (isPointNearElement(pos, el)) {
                        deleteElement(el.id);
                        break; // Delete one at a time to avoid issues
                    }
                }
                return;
            }

            if (isDrawing && activeTool === 'pen') {
                // Snap to ruler edge if near
                    ...selectionBox,
    x: width < 0 ? pos.x : selectionBox.startX,
        y: height < 0 ? pos.y : selectionBox.startY,
            width: Math.abs(width),
                height: Math.abs(height)
                });
            }
        };

const handleMouseUp = () => {
    if (isDrawing && activeTool === 'pen' && currentPath.length > 0) {
        addElement({
            id: Date.now(),
            type: 'stroke',
            points: currentPath,
            color: toolProperties.color,
            thickness: toolProperties.thickness,
            opacity: toolProperties.opacity
        });
        setCurrentPath([]);
    }

    if (selectionBox && activeTool === 'select') {
        // Find all elements within selection box
        const selected = elements.filter(el => {
            if (el.type === 'stroke') {
                const bounds = getStrokeBounds(el);
                return bounds && pointInRect(bounds.x + bounds.width / 2, bounds.y + bounds.height / 2, selectionBox);
            } else if (el.type === 'text' || el.type === 'equation') {
                return pointInRect(el.x, el.y, selectionBox);
            }
            return false;
        });
        setSelectedElements(selected);
        setSelectionBox(null);
    }

    setIsDrawing(false);
    setIsErasing(false);
    setDraggedElement(null);
};

// Draw current path in real-time
useEffect(() => {
    if (currentPath.length > 0) {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');

        redrawCanvas();

        ctx.beginPath();
        ctx.strokeStyle = toolProperties.color;
        ctx.lineWidth = toolProperties.thickness;
        ctx.globalAlpha = toolProperties.opacity;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        ctx.moveTo(currentPath[0].x, currentPath[0].y);
        for (let i = 1; i < currentPath.length; i++) {
            ctx.lineTo(currentPath[i].x, currentPath[i].y);
        }
        let minY = Infinity;
        let avgX = 0;

        selectedElements.forEach(el => {
            if (el.type === 'stroke') {
                const bounds = getStrokeBounds(el);
                if (bounds) {
                    minY = Math.min(minY, bounds.y);
                    avgX += bounds.x + bounds.width / 2;
                }
            } else {
                minY = Math.min(minY, el.y);
                avgX += el.x;
            }
        });

        avgX /= selectedElements.length;

        return { x: avgX, y: minY };
    };

    return (
        <>
            <canvas
                ref={canvasRef}
                onMouseDown={handleMouseDown}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
                style={{
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    cursor: activeTool === 'pen' ? 'crosshair' : activeTool === 'eraser' ? 'pointer' : 'default'
                }}
            />
            {selectedElements.length > 0 && (
                <SelectionActionMenu
                    selectedElements={selectedElements}
                    onDelete={handleDeleteSelected}
                    position={getActionMenuPosition()}
                />
            )}
        </>
    );
};

export default Whiteboard;
